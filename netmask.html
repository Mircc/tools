<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å­ç½‘æ©ç è®¡ç®—å™¨ - IPv4 & IPv6 çº¯å‰ç«¯å·¥å…·</title>
    <meta name="description" content="çº¯å‰ç«¯åœ¨çº¿å­ç½‘æ©ç è®¡ç®—å™¨ã€‚æ”¯æŒ IPv4 å’Œ IPv6ï¼Œæ ¹æ®åœ°å€å’Œæ©ç /å‰ç¼€è®¡ç®—åœ°å€èŒƒå›´ï¼Œæˆ–æ ¹æ® IP èŒƒå›´åæ¨å­ç½‘æ©ç /å‰ç¼€ã€‚">
    
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --border: #e2e8f0;
            --text-main: #1e293b;
            --text-sub: #64748b;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --radius: 12px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: var(--bg);
            color: var(--text-main);
            margin: 0;
            line-height: 1.6;
            min-height: 100vh;
        }

        /* --- å¯¼èˆªæ  --- */
        .navbar {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(0,0,0,0.05);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .nav-container {
            max-width: 1000px;
            margin: 0 auto;
            height: 64px;
            padding: 0 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .nav-logo {
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--primary);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .nav-links { display: flex; gap: 20px; }
        .nav-link {
            text-decoration: none;
            color: var(--text-sub);
            font-weight: 500;
            font-size: 0.9rem;
            transition: color 0.2s;
        }
        .nav-link:hover { color: var(--primary); }
        .nav-link.current { color: var(--primary); font-weight: 600; }
        @media (max-width: 768px) { .nav-links { display: none; } }

        /* --- ä¸»å®¹å™¨ --- */
        .main-container {
            max-width: 800px;
            margin: 40px auto 60px;
            padding: 0 20px;
        }

        .header-section { text-align: center; margin-bottom: 40px; }
        h1 {
            font-size: 2.2rem;
            font-weight: 800;
            margin-bottom: 10px;
            color: var(--text-main);
            letter-spacing: -0.02em;
        }
        .subtitle {
            font-size: 1.05rem;
            color: var(--text-sub);
            font-weight: 400;
        }

        /* --- æ ¸å¿ƒå¡ç‰‡ --- */
        .tool-card-main {
            background: var(--card-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            padding: 32px;
            border: 1px solid var(--border);
            position: relative;
        }

        /* æ¨¡å¼åˆ‡æ¢ */
        .mode-toggle {
            display: flex;
            background: var(--bg);
            border-radius: var(--radius);
            padding: 4px;
            margin-bottom: 25px;
        }
        .mode-button {
            flex: 1;
            padding: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            border: none;
            background: transparent;
            color: var(--text-sub);
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
        }
        .mode-button.active {
            background: var(--primary);
            color: white;
            box-shadow: var(--shadow-sm);
        }

        /* è¾“å…¥ç»„æ ·å¼ */
        .input-group { margin-bottom: 20px; }
        .input-group label {
            display: block;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-main);
            margin-bottom: 8px;
        }
        
        .ip-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 1rem;
            background: var(--card-bg);
            color: var(--text-main);
            box-sizing: border-box;
            transition: all 0.2s;
            font-family: monospace;
            outline: none;
        }
        
        .ip-input:focus {
             border-color: var(--primary); 
             box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
        }
        
        /* æŒ‰é’® */
        .btn-action {
            width: 100%;
            padding: 14px;
            font-size: 1.05rem;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            background: var(--primary);
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.25);
        }
        .btn-action:hover { background: var(--primary-hover); transform: translateY(-1px); }
        .btn-action:disabled { opacity: 0.7; cursor: not-allowed; transform: none; box-shadow: none; }

        /* ç»“æœæ˜¾ç¤ºåŒº */
        .result-panel {
            margin-top: 25px;
            display: none;
            border-top: 1px solid var(--border);
            padding-top: 20px;
        }
        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px dashed var(--border);
            font-size: 0.95rem;
        }
        .result-item:last-child { border-bottom: none; }

        .result-label {
            color: var(--text-sub);
            font-weight: 500;
        }
        .result-value {
            color: var(--text-main);
            font-family: monospace;
            font-weight: 600;
            text-align: right; /* IPåœ°å€é å³å¯¹é½ */
        }
        .result-error-box {
            background: #fee2e2;
            color: #991b1b;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 500;
        }

        footer { text-align: center; color: var(--text-sub); font-size: 0.8rem; margin-top: 60px; padding-bottom: 30px; border-top: 1px solid var(--border); padding-top: 30px; }
    </style>
</head>
<body>

<nav class="navbar">
    <div class="nav-container">
        <a href="#" class="nav-logo">ğŸ”’ å®‰å…¨å·¥å…·ç®±</a>
        <div class="nav-links">
            <a href="#" class="nav-link current">å­ç½‘è®¡ç®—</a>
        </div>
    </div>
</nav>

<div class="main-container">
    
    <div class="header-section">
        <h1>å­ç½‘æ©ç è®¡ç®—å™¨</h1>
        <div class="subtitle">å…¨é¢æ”¯æŒ IPv4 / IPv6 çš„ CIDR/IP èŒƒå›´å¿«é€Ÿè®¡ç®—ä¸åˆ†æï¼Œçº¯å‰ç«¯å®ç°</div>
    </div>

    <div class="tool-card-main">
        
        <div class="mode-toggle">
            <button class="mode-button active" data-mode="cidr">CIDR/æ©ç ä½è®¡ç®—</button>
            <button class="mode-button" data-mode="range">IP èŒƒå›´åæ¨</button>
        </div>

        <div id="modeCidr" class="mode-content">
            <div class="input-group">
                <label for="cidrCombinedInput">è¾“å…¥ IP åœ°å€å’Œæ©ç ä½/å‰ç¼€ (e.g. 192.168.1.1/24 æˆ– 2001:db8::1/64)</label>
                <input type="text" id="cidrCombinedInput" placeholder="192.168.1.1/24 æˆ– 2001:db8::1/64" class="ip-input">
            </div>
            <button id="calcCidrBtn" class="btn-action">ğŸ” è®¡ç®—å­ç½‘ä¿¡æ¯</button>
        </div>

        <div id="modeRange" class="mode-content" style="display: none;">
            <div class="input-group">
                <label for="firstIpInput">èµ·å§‹å¯ç”¨ IP åœ°å€</label>
                <input type="text" id="firstIpInput" placeholder="192.168.1.1 æˆ– 2001:db8::1" class="ip-input">
            </div>
            <div class="input-group">
                <label for="lastIpInput">ç»“æŸå¯ç”¨ IP åœ°å€</label>
                <input type="text" id="lastIpInput" placeholder="192.168.1.254 æˆ– 2001:db8::ffff" class="ip-input">
            </div>
            <button id="calcRangeBtn" class="btn-action">â†©ï¸ åæ¨å­ç½‘æ©ç /å‰ç¼€</button>
        </div>

        <div id="resultPanel" class="result-panel">
            <div id="resultError" class="result-error-box" style="display: none;"></div>
            <div id="resultOutput">
                </div>
        </div>
    </div>

    <footer>
        ç½‘ç»œå·¥å…· | çº¯å‰ç«¯è®¡ç®— | æ‚¨çš„æ•°æ®ä¸ä¼šä¸Šä¼ 
    </footer>
</div>

<script>
    // --- æ ¸å¿ƒå·¥å…·å‡½æ•° ---

    function showError(message, resultError, resultPanel, resultOutput) {
        resultError.textContent = message;
        resultError.style.display = 'block';
        resultPanel.style.display = 'block';
        resultOutput.innerHTML = ''; // æ¸…ç©ºæˆåŠŸç»“æœ
    }
    
    // ä¸­è‹±æ–‡ç¬¦å·å®¹é”™
    function cleanInput(input) {
        if (typeof input !== 'string') return input;
        // æ›¿æ¢ä¸­æ–‡å¥å·å’Œä¸­æ–‡å†’å·
        return input.replace(/ã€‚/g, '.').replace(/ï¼š/g, ':').trim();
    }

    // --- IP ç‰ˆæœ¬æ£€æµ‹ ---
    function getIPVersion(input) {
        const ipStr = input.split('/')[0].trim();
        if (ipStr.includes(':')) {
            // ç®€å•æ ¡éªŒ IPv6
            return isValidIPv6(ipStr) ? 'IPv6' : 'Invalid';
        }
        if (ipStr.includes('.')) {
            // ç®€å•æ ¡éªŒ IPv4
            return isValidIp(ipStr) ? 'IPv4' : 'Invalid';
        }
        return 'Invalid';
    }

    // =================================================================
    //                           IPv4 æ ¸å¿ƒé€»è¾‘
    // =================================================================

    // æ£€æŸ¥IPv4åœ°å€æ ¼å¼æ˜¯å¦æœ‰æ•ˆ
    function isValidIp(ip) {
        if (!ip || ip.length === 0) return false;
        const regex = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
        if (!regex.test(ip)) return false;
        return ip.split('.').every(octet => {
            const num = parseInt(octet);
            return num >= 0 && num <= 255;
        });
    }

    // IPv4åœ°å€ (å­—ç¬¦ä¸²) è½¬æ¢ä¸º 32ä½æ•´æ•°
    function ipToInt(ip) {
        return ip.split('.').reduce((acc, octet) => (acc << 8) + parseInt(octet), 0) >>> 0;
    }

    // 32ä½æ•´æ•° è½¬æ¢ä¸º IPv4åœ°å€ (å­—ç¬¦ä¸²)
    function intToIp(int) {
        return [
            (int >>> 24) & 0xFF,
            (int >>> 16) & 0xFF,
            (int >>> 8) & 0xFF,
            int & 0xFF
        ].join('.');
    }

    // è®¡ç®— IPv4 å­ç½‘æ©ç  (32ä½æ•´æ•°)
    function getV4MaskInt(cidr) {
        if (cidr < 0 || cidr > 32) return 0;
        return cidr === 0 ? 0 : (0xFFFFFFFF << (32 - cidr)) >>> 0;
    }

    // è®¡ç®— IPv4 å­ç½‘æ©ç  (IPæ ¼å¼)
    function getV4MaskIp(cidr) {
        return intToIp(getV4MaskInt(cidr));
    }


    // =================================================================
    //                           IPv6 æ ¸å¿ƒé€»è¾‘
    // =================================================================

    // æ£€æŸ¥IPv6åœ°å€æ ¼å¼æ˜¯å¦æœ‰æ•ˆ (ç®€åŒ–ç‰ˆ)
    function isValidIPv6(ip) {
        if (!ip || ip.length === 0) return false;
        const parts = ip.split(':');
        let emptyCount = 0;
        
        for (const part of parts) {
            if (part === '') {
                emptyCount++;
            } else if (!/^[0-9a-fA-F]{1,4}$/.test(part)) {
                return false;
            }
        }
        
        const nonNullParts = parts.filter(p => p !== '').length;
        if (ip.includes('::')) {
             return nonNullParts <= 7 && emptyCount <= 2;
        } else {
            return parts.length === 8;
        }
    }

    // æ‰©å±•å‹ç¼©çš„ IPv6 åœ°å€åˆ°å®Œæ•´ 32 ä½åå…­è¿›åˆ¶å­—ç¬¦ä¸²
    function normalizeIPv6(ip) {
        if (!ip.includes('::')) {
            return ip.split(':').map(p => p.padStart(4, '0')).join('').toLowerCase();
        }

        const [start, end] = ip.split('::');
        const startParts = start.split(':').filter(p => p.length > 0);
        const endParts = end.split(':').filter(p => p.length > 0);
        
        const missingChunks = 8 - startParts.length - endParts.length;
        // é¿å…åœ¨ start æˆ– end ä¸ºç©ºæ—¶å‡ºç° '00000000'
        const padding = new Array(Math.max(0, missingChunks)).fill('0000').join('');
        
        const startHex = startParts.map(p => p.padStart(4, '0')).join('');
        const endHex = endParts.map(p => p.padStart(4, '0')).join('');
        
        const hex = startHex + padding + endHex;
        return hex.toLowerCase();
    }

    // å°† 32 ä½åå…­è¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢ä¸º BigInt
    function ipV6ToBigInt(hex32String) {
        if (typeof BigInt === 'undefined') {
             throw new TypeError("BigInt not supported");
        }
        return BigInt('0x' + hex32String);
    }

    // å°† BigInt è½¬æ¢ä¸ºå‹ç¼©çš„ IPv6 å­—ç¬¦ä¸² (ç”¨äºæ˜¾ç¤º)
    function bigIntToCompressedIPv6(bigInt) {
        let hex = bigInt.toString(16).padStart(32, '0');
        let parts = [];
        for (let i = 0; i < 32; i += 4) {
            parts.push(hex.substring(i, i + 4));
        }
        
        parts = parts.map(p => p.replace(/^0+/, '') || '0');

        let maxZeros = 0;
        let maxIndex = -1;
        let currentZeros = 0;
        let startIndex = -1;
        
        // æ‰¾åˆ°æœ€é•¿çš„è¿ç»­ '0' åºåˆ— (ç”¨äº '::' å‹ç¼©)
        for (let i = 0; i < parts.length; i++) {
            if (parts[i] === '0') {
                if (currentZeros === 0) startIndex = i;
                currentZeros++;
            } else {
                if (currentZeros > maxZeros) {
                    maxZeros = currentZeros;
                    maxIndex = startIndex;
                }
                currentZeros = 0;
            }
        }
        // æ£€æŸ¥æœ«å°¾çš„åºåˆ—
        if (currentZeros > maxZeros) {
            maxZeros = currentZeros;
            maxIndex = startIndex;
        }

        if (maxZeros >= 2) {
            parts.splice(maxIndex, maxZeros, '');
        }
        
        // ç‰¹æ®Šå¤„ç†å¼€å¤´æˆ–ç»“å°¾æ˜¯ç©ºå­—ç¬¦ä¸²çš„æƒ…å†µ (ä¾‹å¦‚ ::1 æˆ– 1::)
        let result = parts.join(':').toLowerCase();
        if (result.startsWith(':')) result = ':' + result;
        if (result.endsWith(':') && !result.endsWith('::')) result = result + ':';
        
        return result.replace(/:::/g, '::'); // ä¿®å¤å¯èƒ½å¤šä½™çš„å†’å·
    }

    // è®¡ç®— IPv6 ç½‘ç»œæ©ç  (BigInt)
    function getV6MaskBigInt(prefix) {
        if (prefix < 0 || prefix > 128) return 0n;
        if (prefix === 0) return 0n;
        
        const hostBits = 128n - BigInt(prefix);
        const allOnes = (1n << 128n) - 1n; // 128ä¸ª 1
        const hostOnes = (1n << hostBits) - 1n; // 128-prefix ä¸ª 1
        
        return allOnes ^ hostOnes;
    }

    // =================================================================
    //                           åŠŸèƒ½å®ç° (CIDR æ¨¡å¼)
    // =================================================================

    function calculateCidrDetails() {
        const rawInput = document.getElementById('cidrCombinedInput').value;
        const combinedInput = cleanInput(rawInput); // åº”ç”¨å®¹é”™
        
        const resultPanel = document.getElementById('resultPanel');
        const resultError = document.getElementById('resultError');
        const resultOutput = document.getElementById('resultOutput');
        
        resultError.style.display = 'none';
        resultOutput.innerHTML = '';
        resultPanel.style.display = 'none';

        try {
            const parts = combinedInput.split('/');
            let ipStr, prefix;

            // è§£æè¾“å…¥
            if (parts.length === 2) {
                ipStr = parts[0].trim();
                prefix = parseInt(parts[1].trim());
            } else if (parts.length === 1) {
                ipStr = parts[0].trim();
                const version = getIPVersion(ipStr);
                if (version === 'IPv4') {
                    prefix = 32;
                } else if (version === 'IPv6') {
                    prefix = 128;
                } else {
                     showError("è¾“å…¥æ ¼å¼é”™è¯¯ã€‚è¯·ä½¿ç”¨ 'IPåœ°å€/æ©ç ä½æˆ–å‰ç¼€' æ ¼å¼ã€‚", resultError, resultPanel, resultOutput);
                     return;
                }
            } else {
                showError("è¾“å…¥æ ¼å¼é”™è¯¯ã€‚è¯·ä½¿ç”¨ 'IPåœ°å€/æ©ç ä½æˆ–å‰ç¼€' æ ¼å¼ã€‚", resultError, resultPanel, resultOutput);
                return;
            }

            const version = getIPVersion(ipStr);
            if (version === 'Invalid') {
                 showError("æ— æ³•è¯†åˆ«çš„ IP åœ°å€æ ¼å¼ã€‚", resultError, resultPanel, resultOutput);
                 return;
            }

            if (version === 'IPv4' && (isNaN(prefix) || prefix < 0 || prefix > 32)) {
                showError("IPv4 æ©ç ä½å¿…é¡»åœ¨ 0 åˆ° 32 ä¹‹é—´ã€‚", resultError, resultPanel, resultOutput);
                return;
            }
            if (version === 'IPv6' && (isNaN(prefix) || prefix < 0 || prefix > 128)) {
                showError("IPv6 å‰ç¼€é•¿åº¦å¿…é¡»åœ¨ 0 åˆ° 128 ä¹‹é—´ã€‚", resultError, resultPanel, resultOutput);
                return;
            }
            
            // --- IPv4 è®¡ç®—é€»è¾‘ ---
            if (version === 'IPv4') {
                const ipInt = ipToInt(ipStr);
                const maskInt = getV4MaskInt(prefix);
                const networkInt = (ipInt & maskInt) >>> 0;
                
                const hostBits = 32 - prefix;
                const totalAddresses = 1 << hostBits;
                const broadcastInt = (networkInt | (totalAddresses - 1)) >>> 0;

                // ç¡®å®šå¯ç”¨ IP èŒƒå›´
                let firstAvailableIp, lastAvailableIp, totalHostsDisplay;

                if (prefix === 32) {
                    firstAvailableIp = intToIp(networkInt);
                    lastAvailableIp = intToIp(networkInt);
                    totalHostsDisplay = '1';
                } else if (prefix === 31) {
                    firstAvailableIp = intToIp(networkInt);
                    lastAvailableIp = intToIp(broadcastInt);
                    totalHostsDisplay = '2 (ç‚¹å¯¹ç‚¹)';
                } else if (totalAddresses >= 4) {
                    firstAvailableIp = intToIp(networkInt + 1);
                    lastAvailableIp = intToIp(broadcastInt - 1);
                    totalHostsDisplay = (totalAddresses - 2).toLocaleString();
                } else {
                    firstAvailableIp = 'N/A';
                    lastAvailableIp = 'N/A';
                    totalHostsDisplay = '0';
                }
                
                const results = [
                    { label: "IP ç‰ˆæœ¬", value: "IPv4" },
                    { label: "IP æ•°é‡ (æ€»)", value: totalAddresses.toLocaleString() },
                    { label: "IP æ•°é‡ (å¯ç”¨)", value: totalHostsDisplay },
                    { label: "ç½‘ç»œåœ°å€", value: intToIp(networkInt) },
                    { label: "å­ç½‘æ©ç ", value: getV4MaskIp(prefix) },
                    { label: "æ©ç ä½ (CIDR)", value: `/${prefix}` },
                    { label: "ç¬¬ä¸€ä¸ªå¯ç”¨ IP", value: firstAvailableIp },
                    { label: "æœ€åä¸€ä¸ªå¯ç”¨ IP", value: lastAvailableIp },
                    { label: "å¹¿æ’­åœ°å€", value: intToIp(broadcastInt) }
                ];

                results.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'result-item';
                    div.innerHTML = `<span class="result-label">${item.label}</span><span class="result-value">${item.value}</span>`;
                    resultOutput.appendChild(div);
                });

            // --- IPv6 è®¡ç®—é€»è¾‘ ---
            } else if (version === 'IPv6') {
                const normalizedIp = normalizeIPv6(ipStr);
                const ipInt = ipV6ToBigInt(normalizedIp);
                const maskInt = getV6MaskBigInt(prefix);
                const networkInt = (ipInt & maskInt);
                
                const hostBits = 128 - prefix;
                
                const totalAddresses = `2^${hostBits}`;
                const hostOnes = (1n << BigInt(hostBits)) - 1n; 
                const lastAddressInt = networkInt | hostOnes;

                let firstAvailableIp;
                let lastAvailableIp;
                let availableHostsDisplay;

                if (hostBits === 0) { // /128
                    availableHostsDisplay = '1';
                    firstAvailableIp = bigIntToCompressedIPv6(networkInt);
                    lastAvailableIp = bigIntToCompressedIPv6(networkInt);
                } else if (hostBits === 1) { // /127
                    availableHostsDisplay = '2 (ç‚¹å¯¹ç‚¹é“¾è·¯)';
                    firstAvailableIp = bigIntToCompressedIPv6(networkInt);
                    lastAvailableIp = bigIntToCompressedIPv6(lastAddressInt);
                } else {
                    availableHostsDisplay = `2^${hostBits} (ä¸»æœºå®¹é‡)`;
                    firstAvailableIp = bigIntToCompressedIPv6(networkInt + 1n);
                    lastAvailableIp = bigIntToCompressedIPv6(lastAddressInt - 1n);
                }

                const results = [
                    { label: "IP ç‰ˆæœ¬", value: "IPv6" },
                    { label: "IP æ•°é‡ (æ€»)", value: totalAddresses },
                    { label: "IP æ•°é‡ (å¯ç”¨)", value: availableHostsDisplay },
                    { label: "ç½‘ç»œå‰ç¼€", value: `${bigIntToCompressedIPv6(networkInt)}/${prefix}` },
                    { label: "å‰ç¼€é•¿åº¦", value: `/${prefix}` },
                    { label: "ç¬¬ä¸€ä¸ªåœ°å€", value: firstAvailableIp },
                    { label: "æœ€åä¸€ä¸ªåœ°å€", value: lastAvailableIp },
                    { label: "å­ç½‘èŒƒå›´ç»“æŸ", value: bigIntToCompressedIPv6(lastAddressInt) }
                ];

                results.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'result-item';
                    div.innerHTML = `<span class="result-label">${item.label}</span><span class="result-value">${item.value}</span>`;
                    resultOutput.appendChild(div);
                });
            }
            
            resultPanel.style.display = 'block';

        } catch (e) {
            if (e instanceof TypeError && e.message.includes('BigInt')) {
                 showError("è®¡ç®—å‡ºé”™ï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ BigInt ç±»å‹ (IPv6 éœ€è¦)ã€‚è¯·å‡çº§æ‚¨çš„æµè§ˆå™¨ã€‚", resultError, resultPanel, resultOutput);
            } else {
                 showError("è®¡ç®—å‡ºé”™ï¼Œè¯·æ£€æŸ¥è¾“å…¥æ ¼å¼æ˜¯å¦æ­£ç¡®ã€‚", resultError, resultPanel, resultOutput);
            }
            console.error(e);
        }
    }


    // =================================================================
    //                           åŠŸèƒ½å®ç° (èŒƒå›´åæ¨æ¨¡å¼)
    // =================================================================

    function calculateRangeDetails() {
        const firstIpStr = cleanInput(document.getElementById('firstIpInput').value); // åº”ç”¨å®¹é”™
        const lastIpStr = cleanInput(document.getElementById('lastIpInput').value);   // åº”ç”¨å®¹é”™
        
        const resultPanel = document.getElementById('resultPanel');
        const resultError = document.getElementById('resultError');
        const resultOutput = document.getElementById('resultOutput');

        resultError.style.display = 'none';
        resultOutput.innerHTML = '';
        resultPanel.style.display = 'none';

        const version1 = getIPVersion(firstIpStr);
        const version2 = getIPVersion(lastIpStr);

        if (version1 === 'Invalid' || version2 === 'Invalid' || version1 !== version2) {
            showError("è¯·è¾“å…¥ç›¸åŒä¸”æœ‰æ•ˆçš„ IP åœ°å€ç‰ˆæœ¬ (IPv4 æˆ– IPv6)ã€‚", resultError, resultPanel, resultOutput);
            return;
        }

        try {
            // --- IPv4 åæ¨é€»è¾‘ ---
            if (version1 === 'IPv4') {
                const firstIpInt = ipToInt(firstIpStr);
                const lastIpInt = ipToInt(lastIpStr);

                if (firstIpInt >= lastIpInt) {
                    showError("èµ·å§‹ IP å¿…é¡»å°äºç»“æŸ IPã€‚", resultError, resultPanel, resultOutput);
                    return;
                }
                
                const hostCount = lastIpInt - firstIpInt + 1;
                // IPv4 æ€»åœ°å€æ•° = å¯ç”¨åœ°å€æ•° + 2 (é™¤é /31 æˆ– /32)
                const isP2P = (lastIpInt - firstIpInt) === 1 && (firstIpInt % 2 === 0);
                const totalAddressesNeeded = isP2P ? 2 : hostCount + 2; 

                let hostBits = 0;
                while ((1 << hostBits) < totalAddressesNeeded) {
                    hostBits++;
                }
                if (hostBits > 32) hostBits = 32;

                const prefix = 32 - hostBits;
                const maskInt = getV4MaskInt(prefix);
                
                // ç¡®ä¿ç½‘ç»œåœ°å€åœ¨è¾“å…¥èŒƒå›´ä¹‹å‰
                const theoreticalNetworkInt = firstIpInt - (prefix < 31 ? 1 : 0);
                const networkInt = theoreticalNetworkInt & maskInt;
                
                // ç†è®ºä¸Šçš„å¹¿æ’­åœ°å€
                const broadcastInt = networkInt | ((1 << hostBits) - 1);
                
                const firstAvailableInt = networkInt + (prefix < 31 ? 1 : 0);
                const lastAvailableInt = broadcastInt - (prefix < 31 ? 1 : 0);

                // æ ¡éªŒï¼šæ£€æŸ¥è¾“å…¥èŒƒå›´æ˜¯å¦æ°å¥½æ˜¯è®¡ç®—å‡ºçš„å­ç½‘çš„å¯ç”¨èŒƒå›´
                if (firstIpInt !== firstAvailableInt || lastIpInt !== lastAvailableInt) {
                    // å¯¹äº /31 (P2P), ç½‘ç»œåœ°å€å’Œå¯ç”¨åœ°å€æ˜¯ç›¸åŒçš„
                    if (prefix === 31 && firstIpInt === networkInt && lastIpInt === broadcastInt) {
                        // å¿½ç•¥æ ¡éªŒï¼Œä½¿ç”¨è®¡ç®—ç»“æœ
                    } else {
                        showError(`è¯¥ IPv4 èŒƒå›´ (${firstIpStr} - ${lastIpStr}) æ— æ³•æ„æˆä¸€ä¸ªæ ‡å‡†çš„ /${prefix} å­ç½‘çš„å¯ç”¨èŒƒå›´ã€‚æ ‡å‡†å¯ç”¨èŒƒå›´åº”ä¸º ${intToIp(firstAvailableInt)} - ${intToIp(lastAvailableInt)}ã€‚`, resultError, resultPanel, resultOutput);
                        return;
                    }
                }
                
                const results = [
                    { label: "IP ç‰ˆæœ¬", value: "IPv4" },
                    { label: "IP æ•°é‡ (å¯ç”¨)", value: hostCount.toLocaleString() },
                    { label: "æ©ç ä½ (CIDR)", value: `/${prefix}` },
                    { label: "å­ç½‘æ©ç ", value: getV4MaskIp(prefix) },
                    { label: "ç½‘ç»œåœ°å€", value: intToIp(networkInt) },
                    { label: "å¹¿æ’­åœ°å€", value: intToIp(broadcastInt) }
                ];

                results.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'result-item';
                    div.innerHTML = `<span class="result-label">${item.label}</span><span class="result-value">${item.value}</span>`;
                    resultOutput.appendChild(div);
                });

            // --- IPv6 åæ¨é€»è¾‘ ---
            } else if (version1 === 'IPv6') {
                const firstIpInt = ipV6ToBigInt(normalizeIPv6(firstIpStr));
                const lastIpInt = ipV6ToBigInt(normalizeIPv6(lastIpStr));
                
                if (firstIpInt >= lastIpInt) {
                    showError("èµ·å§‹ IP å¿…é¡»å°äºç»“æŸ IPã€‚", resultError, resultPanel, resultOutput);
                    return;
                }
                
                const hostCountBigInt = lastIpInt - firstIpInt + 1n;
                
                // 1. ç¡®å®šæœ€å°å—å¤§å° (2^hostBits >= hostCount)
                let hostBits = 0;
                let totalAddressesPowerOfTwo = 1n;
                while (totalAddressesPowerOfTwo < hostCountBigInt) {
                    totalAddressesPowerOfTwo *= 2n;
                    hostBits++;
                }

                const prefix = 128 - hostBits;
                
                if (prefix < 0) {
                     showError("IP èŒƒå›´è¿‡å¤§ï¼Œè¶…å‡º IPv6 åœ°å€ç©ºé—´é™åˆ¶ã€‚", resultError, resultPanel, resultOutput);
                     return;
                }

                const maskInt = getV6MaskBigInt(prefix);
                
                // 2. æ ¹æ®ç”¨æˆ·è¾“å…¥çš„èµ·å§‹åœ°å€ï¼Œè®¡ç®—å…¶æ‰€åœ¨çš„æ ‡å‡†ç½‘ç»œåœ°å€
                let baseNetworkInt;
                if (hostBits <= 1) { // /127, /128ï¼šå…¨èŒƒå›´å¯ç”¨
                    baseNetworkInt = firstIpInt;
                } else { // /126 åŠä»¥ä¸‹ï¼šé€šå¸¸çº¦å®šç¬¬ä¸€ä¸ª/æœ€åä¸€ä¸ªåœ°å€ä¸ä½œä¸ºä¸»æœºåœ°å€
                    baseNetworkInt = firstIpInt - 1n; 
                }
                
                const networkInt = (baseNetworkInt & maskInt);
                const subnetEndInt = networkInt | ((1n << BigInt(hostBits)) - 1n);

                // 3. æ ¡éªŒè¾“å…¥èŒƒå›´æ˜¯å¦ä¸è®¡ç®—å‡ºçš„æ ‡å‡†å­ç½‘å®Œç¾åŒ¹é…
                let expectedFirst, expectedLast;
                if (hostBits <= 1) { // /127, /128
                    expectedFirst = networkInt;
                    expectedLast = subnetEndInt;
                } else { // /126 åŠä»¥ä¸‹
                    expectedFirst = networkInt + 1n;
                    expectedLast = subnetEndInt - 1n;
                }
                
                if (firstIpInt !== expectedFirst || lastIpInt !== expectedLast) {
                    showError(`è¯¥ IPv6 èŒƒå›´ (${firstIpStr} - ${lastIpStr}) æ— æ³•æ„æˆä¸€ä¸ªæ ‡å‡†çš„ /${prefix} å­ç½‘çš„å¯ç”¨èŒƒå›´ã€‚æ ‡å‡†èŒƒå›´åº”ä¸º ${bigIntToCompressedIPv6(expectedFirst)} - ${bigIntToCompressedIPv6(expectedLast)}ã€‚`, resultError, resultPanel, resultOutput);
                    return;
                }
                
                const results = [
                    { label: "IP ç‰ˆæœ¬", value: "IPv6" },
                    { label: "IP æ•°é‡ (å¯ç”¨)", value: hostCountBigInt.toString() },
                    { label: "å‰ç¼€é•¿åº¦ (CIDR)", value: `/${prefix}` },
                    { label: "ç½‘ç»œå‰ç¼€", value: `${bigIntToCompressedIPv6(networkInt)}/${prefix}` },
                    { label: "ç¬¬ä¸€ä¸ªå¯ç”¨ IP", value: bigIntToCompressedIPv6(firstIpInt) },
                    { label: "æœ€åä¸€ä¸ªå¯ç”¨ IP", value: bigIntToCompressedIPv6(lastIpInt) },
                    { label: "å­ç½‘èŒƒå›´ç»“æŸ", value: bigIntToCompressedIPv6(subnetEndInt) }
                ];
                
                results.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'result-item';
                    div.innerHTML = `<span class="result-label">${item.label}</span><span class="result-value">${item.value}</span>`;
                    resultOutput.appendChild(div);
                });
            }
            
            resultPanel.style.display = 'block';

        } catch (e) {
            if (e instanceof TypeError && e.message.includes('BigInt')) {
                 showError("è®¡ç®—å‡ºé”™ï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ BigInt ç±»å‹ (IPv6 éœ€è¦)ã€‚è¯·å‡çº§æ‚¨çš„æµè§ˆå™¨ã€‚", resultError, resultPanel, resultOutput);
            } else {
                 showError("è®¡ç®—å‡ºé”™ï¼Œè¯·æ£€æŸ¥IPæ ¼å¼å’ŒèŒƒå›´ã€‚", resultError, resultPanel, resultOutput);
            }
            console.error(e);
        }
    }


    // --- UI äº¤äº’ ---

    function switchMode(mode) {
        document.querySelectorAll('.mode-button').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`.mode-button[data-mode="${mode}"]`).classList.add('active');

        document.getElementById('modeCidr').style.display = mode === 'cidr' ? 'block' : 'none';
        document.getElementById('modeRange').style.display = mode === 'range' ? 'block' : 'none';
        
        document.getElementById('resultPanel').style.display = 'none';
    }


    document.addEventListener('DOMContentLoaded', function() {
        // UI å…ƒç´ 
        const cidrCombinedInput = document.getElementById('cidrCombinedInput');
        const firstIpInput = document.getElementById('firstIpInput');
        const lastIpInput = document.getElementById('lastIpInput');
        
        // ç»‘å®šæ¨¡å¼åˆ‡æ¢äº‹ä»¶
        document.querySelectorAll('.mode-button').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const mode = e.target.getAttribute('data-mode');
                switchMode(mode);
            });
        });
        
        // ç»‘å®šè®¡ç®—æŒ‰é’®äº‹ä»¶
        document.getElementById('calcCidrBtn').addEventListener('click', calculateCidrDetails);
        document.getElementById('calcRangeBtn').addEventListener('click', calculateRangeDetails);
        
        // ç»‘å®šå›è½¦é”®è§¦å‘è®¡ç®—
        cidrCombinedInput.addEventListener('keydown', e => { 
            if (e.key === 'Enter') {
                e.preventDefault();
                calculateCidrDetails(); 
            }
        });
        
        firstIpInput.addEventListener('keydown', e => { 
            if (e.key === 'Enter') {
                e.preventDefault();
                calculateRangeDetails(); 
            }
        });
        lastIpInput.addEventListener('keydown', e => { 
            if (e.key === 'Enter') {
                e.preventDefault();
                calculateRangeDetails(); 
            }
        });
        
        // åˆå§‹è®¾ç½®ä¸ºCIDRæ¨¡å¼
        switchMode('cidr');
    });
</script>
</body>
</html>
