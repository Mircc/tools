<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é€šç”¨åŠ è§£å¯†å·¥å…·</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg: #f8fafc;
            --card: #ffffff;
            --border: #e2e8f0;
            --text-main: #1e293b;
            --text-sub: #64748b;
            --error: #ef4444;
            --success: #10b981;
            --warn: #f59e0b;
            --radius: 12px;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        .container { max-width: 800px; margin: 0 auto; }
        
        h1 { color: var(--text-main); text-align: center; margin-bottom: 20px; font-size: 2rem; }
        h3 { font-size: 1.1rem; color: var(--text-main); margin-bottom: 10px; }

        .card {
            background: var(--card);
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            margin-bottom: 30px;
        }
        
        /* Layout */
        .controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .input-group { width: 100%; }

        /* Input Styles */
        label { display: block; font-weight: 600; font-size: 0.9em; margin-bottom: 8px; color: var(--text-sub); }

        input[type="text"], select, textarea {
            width: 100%; padding: 10px 12px; border: 1px solid var(--border); border-radius: 8px;
            font-size: 14px; box-sizing: border-box; background: #fff; color: var(--text-main);
            font-family: monospace; resize: vertical; min-height: 40px;
        }
        textarea { min-height: 150px; }
        input:focus, select:focus, textarea:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1); }

        /* Buttons */
        .btn-action { 
            width: 100%; padding: 12px; font-size: 1.1rem; font-weight: 600; border: none; border-radius: 8px;
            background: var(--primary); color: white; cursor: pointer; transition: all 0.2s;
        }
        .btn-action:hover { background: var(--primary-hover); }
        .btn-action:disabled { opacity: 0.6; cursor: not-allowed; background: #9ca3af; }

        /* Status */
        .status-message { min-height: 1.5em; margin-top: 10px; font-size: 0.9em; color: var(--error); }
        .status-ok { color: var(--success); }
        .status-warn { color: var(--warn); }
        
        .result-box {
            background: #f1f5f9; padding: 15px; border-radius: 8px; margin-top: 10px;
            font-family: monospace; font-size: 0.9em; min-height: 100px; word-break: break-all;
            resize: vertical;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>é€šç”¨åŠ è§£å¯†å·¥å…·</h1>

    <div class="card">
        <h3>å¯†é’¥ä¸ç®—æ³•è®¾ç½®</h3>
        <div class="controls-grid">
            <div class="input-group">
                <label for="secretKey">å¯†é’¥ (å¯é€‰)</label>
                <input type="text" id="secretKey" placeholder="é»˜è®¤å¯†é’¥: tools.eu.org">
            </div>
            <div class="input-group">
                <label for="algorithmSelect">åŠ å¯†ç®—æ³•</label>
                <select id="algorithmSelect">
                    <option value="AES-256-CBC" selected>AES-256-CBC (æ¨è)</option>
                    <option value="AES-128-CBC">AES-128-CBC</option>
                    <option value="RC4">RC4</option>
                    <option value="SHA-256">SHA-256 (å“ˆå¸Œæ ¡éªŒ)</option>
                    <option value="SHA-512">SHA-512 (å“ˆå¸Œæ ¡éªŒ)</option>
                </select>
            </div>
        </div>
        
        <div class="input-group">
            <label for="contentInput">è¾“å…¥å†…å®¹ (æ˜æ–‡æˆ–å¯†æ–‡)</label>
            <textarea id="contentInput" placeholder="è¾“å…¥æ˜æ–‡è¿›è¡ŒåŠ å¯†ï¼Œæˆ–ç²˜è´´å¯†æ–‡è¿›è¡Œè§£å¯†..."></textarea>
        </div>
        
        <button id="mainActionBtn" class="btn-action">ğŸ”’ åŠ å¯†</button>
        
        <div id="actionStatus" class="status-message"></div>

        <div class="input-group">
            <label for="resultOutput">å¤„ç†ç»“æœ (å¯†æ–‡æˆ–æ˜æ–‡)</label>
            <textarea id="resultOutput" class="result-box" readonly placeholder="ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
        </div>
    </div>
</div>

<script>
    // --- é…ç½®å¸¸é‡ ---
    const DEFAULT_KEY = 'tools.eu.org';
    const CIPHER_PREFIX = 'ENC_V1:';
    
    // --- ç®—æ³•æ”¯æŒæ˜ å°„è¡¨ ---
    // ç®€åŒ–åï¼Œæ‰€æœ‰ç®—æ³•å‡è§†ä¸º 'supported: true'ï¼Œä½¿ç”¨ CryptoJS å®ç°
    const ALGORITHGM_SUPPORT = {
        'AES-256-CBC': { type: 'symmetric', keyLen: 256, algo: CryptoJS.AES },
        'AES-128-CBC': { type: 'symmetric', keyLen: 128, algo: CryptoJS.AES },
        'RC4': { type: 'symmetric', keyLen: 128, algo: CryptoJS.RC4 },
        'SHA-256': { type: 'hash', algo: CryptoJS.SHA256 },
        'SHA-512': { type: 'hash', algo: CryptoJS.SHA512 },
    };

    // --- DOM å…ƒç´  ---
    const secretKeyInput = document.getElementById('secretKey');
    const algorithmSelect = document.getElementById('algorithmSelect');
    const contentInput = document.getElementById('contentInput');
    const mainActionBtn = document.getElementById('mainActionBtn');
    const resultOutput = document.getElementById('resultOutput');
    const actionStatus = document.getElementById('actionStatus');

    // --- è¾…åŠ©å‡½æ•° ---

    const arrayBufferToBase64 = (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer)));
    
    // å¯†æ–‡è¾“å…¥è§£æå™¨
    const parseCipherInput = (content) => {
        const base64Cipher = content.replace(CIPHER_PREFIX, '');
        // ä½¿ç”¨ CryptoJS çš„åŸç”Ÿæ–¹æ³•è§£æ Base64 å­—ç¬¦ä¸²
        return CryptoJS.lib.CipherParams.create({
            ciphertext: CryptoJS.enc.Base64.parse(base64Cipher)
        });
    };
    
    /**
     * æ´¾ç”Ÿå¯†é’¥ (ä½¿ç”¨ CryptoJS çš„ EvpKDF)
     */
    function deriveKey(secretKey) {
        // CryptoJS çš„ EvpKDF ç®€åŒ–äº†å¯†é’¥å’Œç›çš„æ´¾ç”Ÿï¼Œå†…éƒ¨ä½¿ç”¨ MD5
        // å¤–éƒ¨åº“æ— æ³•ç›´æ¥è®¿é—®æ ‡å‡†çš„ Web Crypto PBKDF2ï¼Œæ­¤å¤„æ˜¯æœ€ä½³æ›¿ä»£æ–¹æ¡ˆã€‚
        const salt = CryptoJS.lib.WordArray.random(16); // éšæœºç”Ÿæˆç›å€¼
        const key = CryptoJS.EvpKDF(secretKey, salt, { 
            keySize: 256 / 32, // ç¡®ä¿ Key Size è¶³å¤Ÿå¤§
            iterations: 1 
        });
        return { key, salt };
    }
    
    // --- æ ¸å¿ƒæ“ä½œå‡½æ•° ---

    /**
     * å¤„ç†åŠ å¯†æ“ä½œ
     */
    async function processEncrypt() {
        const content = contentInput.value;
        const secretKey = secretKeyInput.value.trim() || DEFAULT_KEY;
        const algorithm = algorithmSelect.value;
        const algoConfig = ALGORITHGM_SUPPORT[algorithm];
        
        actionStatus.textContent = `å¤„ç†ä¸­... (ç®—æ³•: ${algorithm})`;
        mainActionBtn.disabled = true;
        
        try {
            if (algoConfig.type === 'symmetric') {
                // å¯¹ç§°åŠ å¯†: ä½¿ç”¨å¯†é’¥æ´¾ç”Ÿ
                const key = CryptoJS.enc.Utf8.parse(secretKey); // ç®€åŒ–å¯†é’¥ï¼Œä¸ä½¿ç”¨ KDF (æ›´å¿«)
                // const { key, salt } = deriveKey(secretKey); // å¤æ‚KDF
                
                const encrypted = algoConfig.algo.encrypt(content, key, { 
                    mode: CryptoJS.mode.CBC,
                    padding: CryptoJS.pad.Pkcs7,
                    // ä¸ä½¿ç”¨ IV å’Œ Salt è‡ªåŠ¨ç”Ÿæˆï¼Œä¿æŒå¯†é’¥ç®€å•
                });
                
                // å¯†æ–‡ç»“æ„: Prefix + Base64(Ciphertext)
                resultOutput.value = CIPHER_PREFIX + encrypted.toString();
                actionStatus.textContent = `âœ… åŠ å¯†æˆåŠŸï¼ç®—æ³•: ${algorithm}`;
                actionStatus.classList.add('status-ok');
            
            } else if (algoConfig.type === 'hash') {
                // å“ˆå¸Œæ“ä½œ
                const hash = algoConfig.algo(content);
                resultOutput.value = hash.toString(CryptoJS.enc.Hex);
                actionStatus.textContent = `âœ… ${algorithm} å“ˆå¸Œè®¡ç®—æˆåŠŸï¼`;
                actionStatus.classList.add('status-ok');

            } else {
                throw new Error("ç®—æ³•ä¸å—æ”¯æŒã€‚");
            }
        } catch (e) {
            actionStatus.textContent = `âŒ æ“ä½œå¤±è´¥: ${e.message}`;
            actionStatus.classList.remove('status-ok');
        } finally {
            mainActionBtn.disabled = false;
        }
    }

    /**
     * å¤„ç†è§£å¯†æ“ä½œ
     */
    async function processDecrypt() {
        const content = contentInput.value.trim();
        const secretKey = secretKeyInput.value.trim() || DEFAULT_KEY;
        const algorithm = algorithmSelect.value;
        const algoConfig = ALGORITHGM_SUPPORT[algorithm];

        if (algoConfig.type !== 'symmetric') {
             actionStatus.textContent = "âŒ åªæœ‰å¯¹ç§°åŠ å¯†ç®—æ³•æ”¯æŒè§£å¯†ã€‚";
             return;
        }

        actionStatus.textContent = `å¤„ç†ä¸­... (ç®—æ³•: ${algorithm})`;
        mainActionBtn.disabled = true;

        try {
            const key = CryptoJS.enc.Utf8.parse(secretKey); // ç®€åŒ–å¯†é’¥ï¼Œç›´æ¥ä½¿ç”¨
            
            const decrypted = algoConfig.algo.decrypt(content.replace(CIPHER_PREFIX, ''), key, {
                 mode: CryptoJS.mode.CBC,
                 padding: CryptoJS.pad.Pkcs7
            });

            // æ£€æŸ¥è§£å¯†ç»“æœæ˜¯å¦ä¸ºç©º (å¯†ç é”™è¯¯æˆ–æ•°æ®æŸå)
            if (decrypted.sigBytes === 0) {
                 throw new Error("è§£å¯†å¤±è´¥ï¼šå¯†æ–‡æˆ–å¯†é’¥ä¸æ­£ç¡®ã€‚");
            }

            resultOutput.value = decrypted.toString(CryptoJS.enc.Utf8);
            actionStatus.textContent = `âœ… è§£å¯†æˆåŠŸï¼ç®—æ³•: ${algorithm}`;
            actionStatus.classList.add('status-ok');

        } catch (e) {
            actionStatus.textContent = `âŒ è§£å¯†å¤±è´¥: ${e.message}. è¯·æ£€æŸ¥å¯†é’¥æˆ–å¯†æ–‡æ˜¯å¦æ­£ç¡®ã€‚`;
            actionStatus.classList.remove('status-ok');
        } finally {
            mainActionBtn.disabled = false;
        }
    }

    // --- åˆå§‹åŒ–å’Œäº‹ä»¶ç»‘å®š ---
    function updateActionUI() {
        const content = contentInput.value.trim();
        const algorithm = algorithmSelect.value;
        const isCipher = content.startsWith(CIPHER_PREFIX);
        const algoConfig = ALGORITHGM_SUPPORT[algorithm];
        
        mainActionBtn.disabled = content.length === 0;

        if (isCipher && algoConfig.type === 'symmetric') {
            mainActionBtn.textContent = 'ğŸ”“ è§£å¯†';
            mainActionBtn.dataset.action = 'decrypt';
        } else {
            mainActionBtn.textContent = algoConfig.type === 'hash' ? `ğŸ”¨ ${algorithm}` : 'ğŸ”’ åŠ å¯†';
            mainActionBtn.dataset.action = 'encrypt';
        }
        actionStatus.textContent = '';
        actionStatus.classList.remove('status-warn');
    }
    
    function handleSmartAction() {
        const action = mainActionBtn.dataset.action;
        if (action === 'encrypt') {
            processEncrypt();
        } else if (action === 'decrypt') {
            processDecrypt();
        }
    }

    document.addEventListener('DOMContentLoaded', function() {
        // æ£€æŸ¥å¤–éƒ¨åº“æ˜¯å¦åŠ è½½æˆåŠŸ
        if (typeof CryptoJS === 'undefined') {
             actionStatus.textContent = 'âŒ å¤–éƒ¨åº“ CryptoJS æœªåŠ è½½æˆåŠŸï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–CDNé“¾æ¥ã€‚';
             actionStatus.classList.add('status-error');
             mainActionBtn.disabled = true;
             return;
        }

        // ç»‘å®šäº‹ä»¶
        contentInput.addEventListener('input', updateActionUI);
        algorithmSelect.addEventListener('change', updateActionUI);
        mainActionBtn.addEventListener('click', handleSmartAction);
        
        // ç»‘å®šå›è½¦é”®
        contentInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSmartAction();
            }
        });
        
        // åŒå‡»å¤åˆ¶
        resultOutput.addEventListener('dblclick', function() {
            if (resultOutput.value) {
                 navigator.clipboard.writeText(resultOutput.value).then(() => {
                    actionStatus.textContent = 'ğŸ“‹ å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼';
                    actionStatus.classList.add('status-ok');
                    setTimeout(() => actionStatus.textContent = '', 2000);
                 });
            }
        });
        
        updateActionUI(); // åˆå§‹çŠ¶æ€
    });
</script>
</body>
</html>
