<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSA åŠ å¯†è§£å¯†å·¥å…· - Web Crypto</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg: #f8fafc;
            --card: #ffffff;
            --border: #e2e8f0;
            --text-main: #1e293b;
            --text-sub: #64748b;
            --radius: 12px;
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        .container { max-width: 900px; margin: 0 auto; }
        
        h1 { color: var(--text-main); text-align: center; margin-bottom: 20px; font-size: 2rem; }
        h3 { font-size: 1.1rem; color: var(--primary); margin-top: 15px; margin-bottom: 10px; }

        .card {
            background: var(--card);
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            margin-bottom: 30px;
        }
        
        /* Layout */
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 20px;}

        /* Input Styles */
        .input-group { margin-bottom: 20px; }
        label { display: block; font-weight: 600; font-size: 0.9em; margin-bottom: 8px; color: var(--text-sub); }

        input[type="text"], select, textarea {
            width: 100%; padding: 10px 12px; border: 1px solid var(--border); border-radius: 8px;
            font-size: 14px; box-sizing: border-box; background: #fff; color: var(--text-main);
            font-family: monospace; resize: vertical; min-height: 40px;
        }
        textarea { min-height: 100px; }
        input[type="text"]:focus, select:focus, textarea:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1); }

        /* Buttons */
        .btn { padding: 10px 20px; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-hover); }
        .btn-danger { background: #ef4444; color: white; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; background: #9ca3af; }

        /* Status and Results */
        #mainActionBtn { padding: 12px 20px; font-size: 1.1rem; width: 100%; }

        .status-message { min-height: 1.5em; margin-top: 10px; font-size: 0.9em; color: #ef4444; }
        #keyGenerationStatus { min-height: 1.5em; margin-top: 10px; font-size: 0.9em; color: #22c55e; }
        
        .result-box {
            background: #f1f5f9; padding: 15px; border-radius: 8px; margin-top: 15px;
            font-family: monospace; font-size: 0.9em; min-height: 80px; word-break: break-all;
            cursor: pointer;
        }

        .alert-box {
            background: #fffbe7; color: #92400e; padding: 10px; border-radius: 8px; margin-bottom: 15px; font-size: 0.9em;
        }
        
        /* ä¸¥é‡é”™è¯¯æç¤º */
        .error-banner {
            background: #fee2e2; color: #991b1b; padding: 15px; border-radius: 8px; 
            margin-bottom: 20px; border: 1px solid #f87171; display: none;
            text-align: center; font-weight: 600;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>RSA åŠ å¯†/è§£å¯†å·¥å…·</h1>
    
    <div id="envWarning" class="error-banner">
        âŒ é”™è¯¯ï¼šæ£€æµ‹åˆ°ä¸å®‰å…¨çš„ç¯å¢ƒ (file:// æˆ– http://)ã€‚<br>
        Web Crypto API å¿…é¡»åœ¨ HTTPS æˆ– localhost (æœ¬åœ°æœåŠ¡å™¨) ç¯å¢ƒä¸‹æ‰èƒ½è¿è¡Œã€‚<br>
        è¯·ä½¿ç”¨ VSCode Live Server æˆ–éƒ¨ç½²åˆ° GitHub Pages è®¿é—®ã€‚
    </div>
    
    <div class="alert-box">
        âš ï¸ **é‡è¦æç¤ºï¼š** RSA åŠ å¯†æœ‰æ•°æ®é•¿åº¦é™åˆ¶ï¼ˆé€šå¸¸ä¸ºå¯†é’¥é•¿åº¦å‡å» 42 å­—èŠ‚ï¼‰ã€‚åŠ å¯†æ•°æ®è¿‡é•¿ä¼šå¯¼è‡´å¤±è´¥ã€‚
    </div>

    <div class="card">
        <h2>å¯†é’¥ç”Ÿæˆ (Web Crypto API)</h2>
        
        <div class="grid-3">
            <div class="input-group">
                <label for="keySize">å¯†é’¥ä½æ•°</label>
                <select id="keySize">
                    <option value="2048" selected>2048 bits (æ¨è)</option>
                    <option value="3072">3072 bits</option>
                    <option value="4096">4096 bits</option>
                </select>
            </div>
            <div class="input-group">
                <label for="keyFormat">ç§é’¥æ ¼å¼</label>
                <select id="keyFormat">
                    <option value="pkcs8" selected>PKCS#8 (æ¨è)</option>
                    <option value="pkcs1">PKCS#1 (ä¸æ”¯æŒåŸç”Ÿå¯¼å‡º)</option>
                </select>
            </div>
            <div class="input-group" style="padding-top: 25px;">
                <button id="generateKeyBtn" class="btn btn-primary">ğŸ”‘ ç”Ÿæˆå¯†é’¥å¯¹</button>
            </div>
        </div>
        
        <div id="keyGenerationStatus" style="color:#22c55e;"></div>

        <div class="grid-2">
            <div class="input-group">
                <label for="publicKeyOutput">å…¬é’¥ (SPKI PEM)</label>
                <textarea id="publicKeyOutput" placeholder="ç”Ÿæˆçš„å…¬é’¥å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..." readonly></textarea>
            </div>
            <div class="input-group">
                <label for="privateKeyOutput">ç§é’¥ (PKCS#8 PEM)</label>
                <textarea id="privateKeyOutput" placeholder="ç”Ÿæˆçš„ç§é’¥å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..." readonly></textarea>
            </div>
        </div>
    </div>

    <div class="card">
        <h2>æ•°æ®å¤„ç† (RSA-OAEP)</h2>

        <div class="grid-2">
            <div class="input-group">
                <label for="inputPublicKey">è¾“å…¥å…¬é’¥ (Encrypt)</label>
                <textarea id="inputPublicKey" placeholder="ç”¨äºåŠ å¯†ï¼Œå¯ä»ä¸Šæ–¹å¤åˆ¶"></textarea>
            </div>
            <div class="input-group">
                <label for="inputPrivateKey">è¾“å…¥ç§é’¥ (Decrypt)</label>
                <textarea id="inputPrivateKey" placeholder="ç”¨äºè§£å¯†ï¼Œå¯ä»ä¸Šæ–¹å¤åˆ¶"></textarea>
            </div>
        </div>

        <div class="input-group">
            <label for="contentInput">è¾“å…¥å†…å®¹ (æ˜æ–‡æˆ–å¯†æ–‡)</label>
            <textarea id="contentInput" placeholder="è¾“å…¥æ˜æ–‡è¿›è¡ŒåŠ å¯†ï¼Œæˆ–ç²˜è´´å¯†æ–‡è¿›è¡Œè§£å¯†..."></textarea>
        </div>
        
        <button id="mainActionBtn" class="btn btn-primary">ğŸ”’ åŠ å¯†</button>
        
        <div id="actionStatus" class="status-message"></div>

        <div class="input-group">
            <label for="resultOutput">å¤„ç†ç»“æœ (åŒå‡»å¤åˆ¶)</label>
            <textarea id="resultOutput" class="result-box" readonly title="åŒå‡»è‡ªåŠ¨å¤åˆ¶ç»“æœ"></textarea>
        </div>

    </div>
</div>

<script>
    // --- å¸¸é‡ ---
    const RSA_ALGORITHM = 'RSA-OAEP';
    const HASH_ALGORITHM = 'SHA-256';

    // --- DOM å…ƒç´  ---
    const keySize = document.getElementById('keySize');
    const generateKeyBtn = document.getElementById('generateKeyBtn');
    const publicKeyOutput = document.getElementById('publicKeyOutput');
    const privateKeyOutput = document.getElementById('privateKeyOutput');
    const keyGenerationStatus = document.getElementById('keyGenerationStatus');

    const inputPublicKey = document.getElementById('inputPublicKey');
    const inputPrivateKey = document.getElementById('inputPrivateKey');
    const contentInput = document.getElementById('contentInput');
    const mainActionBtn = document.getElementById('mainActionBtn');
    const resultOutput = document.getElementById('resultOutput');
    const actionStatus = document.getElementById('actionStatus');
    const envWarning = document.getElementById('envWarning');

    // --- åˆå§‹åŒ–æ£€æŸ¥ ---
    window.onload = function() {
        // æ£€æŸ¥ Secure Context
        if (!window.isSecureContext || !window.crypto || !window.crypto.subtle) {
            envWarning.style.display = 'block';
            generateKeyBtn.disabled = true;
            mainActionBtn.disabled = true;
            contentInput.placeholder = "åŠŸèƒ½ä¸å¯ç”¨ï¼šéœ€è¦ HTTPS æˆ– localhost ç¯å¢ƒ";
            return;
        }

        // ç»‘å®šäº‹ä»¶
        generateKeyBtn.addEventListener('click', generateRsaKeyPair);
        contentInput.addEventListener('input', updateActionUI);
        mainActionBtn.addEventListener('click', handleMainAction);
        
        // ç»‘å®šå›è½¦é”® (é˜²æ­¢ shift+enter è§¦å‘)
        contentInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleMainAction();
            }
        });
        
        // åŒå‡»å¤åˆ¶
        resultOutput.addEventListener('dblclick', copyResultToClipboard);
        
        // åˆå§‹ UI çŠ¶æ€
        updateActionUI();
    };

    // --- å·¥å…·å‡½æ•° ---

    const arrayBufferToBase64 = (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer)));
    
    const base64ToArrayBuffer = (base64) => {
        // ç§»é™¤å›è½¦æ¢è¡Œ
        const cleanBase64 = base64.replace(/\s/g, '');
        const binary = atob(cleanBase64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
        }
        return bytes.buffer;
    };
    
    function arrayBufferToPem(buffer, type) {
        const base64 = arrayBufferToBase64(buffer);
        const header = type.includes('PUBLIC') ? 'BEGIN PUBLIC KEY' : 'BEGIN PRIVATE KEY';
        const footer = type.includes('PUBLIC') ? 'END PUBLIC KEY' : 'END PRIVATE KEY';
        return `-----${header}-----\n${base64.match(/.{1,64}/g).join('\n')}\n-----${footer}-----`;
    }

    function pemToArrayBuffer(pem) {
        const base64 = pem.replace(/-----BEGIN [A-Z ]+-----/g, '')
                          .replace(/-----END [A-Z ]+-----/g, '')
                          .replace(/\s/g, ''); 
        return base64ToArrayBuffer(base64);
    }
    
    // --- æ ¸å¿ƒåŠŸèƒ½å®ç° ---

    async function generateRsaKeyPair() {
        const bits = parseInt(keySize.value);
        keyGenerationStatus.textContent = 'ç”Ÿæˆä¸­... (è¿™å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ)';
        keyGenerationStatus.style.color = '#f59e0b';
        generateKeyBtn.disabled = true;

        try {
            const keyPair = await window.crypto.subtle.generateKey(
                {
                    name: RSA_ALGORITHM,
                    modulusLength: bits,
                    publicExponent: new Uint8Array([1, 0, 1]), 
                    hash: HASH_ALGORITHM,
                },
                true, 
                ['encrypt', 'decrypt']
            );

            const publicKeyBuffer = await window.crypto.subtle.exportKey('spki', keyPair.publicKey);
            publicKeyOutput.value = arrayBufferToPem(publicKeyBuffer, 'PUBLIC');
            inputPublicKey.value = publicKeyOutput.value; 

            const privateKeyBuffer = await window.crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
            privateKeyOutput.value = arrayBufferToPem(privateKeyBuffer, 'PRIVATE');
            inputPrivateKey.value = privateKeyOutput.value; 

            keyGenerationStatus.textContent = `âœ… å¯†é’¥å¯¹ç”ŸæˆæˆåŠŸ (${bits} bits)ï¼`;
            keyGenerationStatus.style.color = '#22c55e';
            
        } catch (error) {
            keyGenerationStatus.textContent = `âŒ ç”Ÿæˆå¤±è´¥: ${error.message}`;
            keyGenerationStatus.style.color = '#ef4444';
        } finally {
            generateKeyBtn.disabled = false;
        }
    }

    // ç»Ÿä¸€å¤„ç†åŠ¨ä½œ
    function handleMainAction() {
        const content = contentInput.value.trim();
        if (isLikelyCiphertext(content)) {
            decryptContent();
        } else {
            encryptContent();
        }
    }

    async function encryptContent() {
        const publicKeyPem = inputPublicKey.value.trim();
        const content = contentInput.value;
        actionStatus.textContent = '';

        if (!publicKeyPem) return showStatus('âŒ åŠ å¯†éœ€è¦å…¬é’¥ã€‚', 'error');
        if (content.length === 0) return showStatus('âŒ å†…å®¹ä¸èƒ½ä¸ºç©ºã€‚', 'error');
        
        // æ£€æŸ¥é•¿åº¦
        const contentBytes = new TextEncoder().encode(content);
        const keyLengthBits = parseInt(keySize.value) || 2048; // å‡è®¾é»˜è®¤2048ï¼Œå®é™…åº”è§£ækey
        // RSA-OAEP-SHA256 padding overhead is 2 * hashLength + 2. SHA-256 hash len is 32.
        // Overhead = 2 * 32 + 2 = 66 bytes.
        // Max size = KeySizeBytes - 66.
        const maxDataBytes = (keyLengthBits / 8) - 66; 
        
        if (contentBytes.length > maxDataBytes) {
            return showStatus(`âŒ å†…å®¹è¿‡é•¿ã€‚å½“å‰è®¾ç½®æœ€å¤§æ”¯æŒ ${maxDataBytes} å­—èŠ‚ï¼Œæ‚¨è¾“å…¥äº† ${contentBytes.length} å­—èŠ‚ã€‚`, 'error');
        }

        setLoading(true, 'åŠ å¯†ä¸­...');

        try {
            const publicKeyBuffer = pemToArrayBuffer(publicKeyPem);
            const publicKey = await window.crypto.subtle.importKey(
                'spki', publicKeyBuffer, { name: RSA_ALGORITHM, hash: HASH_ALGORITHM }, false, ['encrypt']
            );

            const encryptedBuffer = await window.crypto.subtle.encrypt(
                { name: RSA_ALGORITHM }, publicKey, contentBytes
            );

            resultOutput.value = arrayBufferToBase64(encryptedBuffer);
            showStatus('âœ… åŠ å¯†æˆåŠŸï¼', 'success');
            
        } catch (error) {
            showStatus(`âŒ åŠ å¯†å¤±è´¥: ${error.message}`, 'error');
        } finally {
            setLoading(false, 'ğŸ”’ åŠ å¯†');
            updateActionUI(); // æ¢å¤æŒ‰é’®çŠ¶æ€
        }
    }

    async function decryptContent() {
        const privateKeyPem = inputPrivateKey.value.trim();
        const ciphertextBase64 = contentInput.value.trim();
        actionStatus.textContent = '';

        if (!privateKeyPem) return showStatus('âŒ è§£å¯†éœ€è¦ç§é’¥ã€‚', 'error');

        setLoading(true, 'è§£å¯†ä¸­...');

        try {
            const privateKeyBuffer = pemToArrayBuffer(privateKeyPem);
            let ciphertextBuffer;
            try {
                ciphertextBuffer = base64ToArrayBuffer(ciphertextBase64);
            } catch(e) {
                throw new Error("å¯†æ–‡ä¸æ˜¯æœ‰æ•ˆçš„ Base64 æ ¼å¼");
            }

            const privateKey = await window.crypto.subtle.importKey(
                'pkcs8', privateKeyBuffer, { name: RSA_ALGORITHM, hash: HASH_ALGORITHM }, false, ['decrypt']
            );

            const decryptedBuffer = await window.crypto.subtle.decrypt(
                { name: RSA_ALGORITHM }, privateKey, ciphertextBuffer
            );

            resultOutput.value = new TextDecoder().decode(decryptedBuffer);
            showStatus('âœ… è§£å¯†æˆåŠŸï¼', 'success');

        } catch (error) {
            showStatus(`âŒ è§£å¯†å¤±è´¥: ${error.message}`, 'error');
        } finally {
            setLoading(false, 'ğŸ”“ è§£å¯†');
            updateActionUI();
        }
    }
    
    // --- æ™ºèƒ½æ£€æµ‹ä¸UIæ›´æ–° ---

    function isLikelyCiphertext(text) {
        if (!text || text.length < 50) return false; 
        // ç®€å•çš„ Base64 å­—ç¬¦é›†æ£€æŸ¥ï¼Œä¸”ä¸å«ç©ºæ ¼ï¼ˆé™¤äº†æ¢è¡Œï¼‰
        // RSA å¯†æ–‡é€šå¸¸è¾ƒé•¿ä¸”çœ‹èµ·æ¥åƒéšæœº Base64
        const base64Pattern = /^[A-Za-z0-9+/=\s]+$/;
        return base64Pattern.test(text);
    }

    function updateActionUI() {
        const content = contentInput.value.trim();
        const isCipher = isLikelyCiphertext(content);

        if (isCipher) {
            mainActionBtn.textContent = 'ğŸ”“ è§£å¯†';
            mainActionBtn.className = 'btn btn-primary'; // å¯é€‰ï¼šç»™è§£å¯†æ¢ä¸ªé¢œè‰²
        } else {
            mainActionBtn.textContent = 'ğŸ”’ åŠ å¯†';
            mainActionBtn.className = 'btn btn-primary';
        }
    }
    
    function copyResultToClipboard() {
        if (!resultOutput.value) return;
        resultOutput.select();
        document.execCommand('copy');
        const originalStatus = actionStatus.textContent;
        actionStatus.textContent = 'ğŸ“‹ å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼';
        actionStatus.style.color = '#2563eb';
        setTimeout(() => actionStatus.textContent = originalStatus, 2000);
    }

    function showStatus(msg, type) {
        actionStatus.textContent = msg;
        actionStatus.style.color = type === 'error' ? '#ef4444' : '#22c55e';
    }

    function setLoading(isLoading, text) {
        mainActionBtn.disabled = isLoading;
        mainActionBtn.textContent = text;
    }

</script>
</body>
</html>
