<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSA åŠ å¯†è§£å¯†å·¥å…· - Web Crypto</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg: #f8fafc;
            --card: #ffffff;
            --border: #e2e8f0;
            --text-main: #1e293b;
            --text-sub: #64748b;
            --radius: 12px;
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        .container { max-width: 900px; margin: 0 auto; }
        
        h1 { color: var(--text-main); text-align: center; margin-bottom: 20px; font-size: 2rem; }

        .card {
            background: var(--card);
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            margin-bottom: 30px;
        }
        
        /* å¸ƒå±€å·¥å…·ç±» */
        .flex-row { display: flex; gap: 15px; align-items: end; margin-bottom: 15px; flex-wrap: wrap; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }

        /* è¾“å…¥æ¡†æ ·å¼ */
        .input-wrapper { flex: 1; }
        label { display: block; font-weight: 600; font-size: 0.9em; margin-bottom: 6px; color: var(--text-sub); }

        input[type="text"], select, textarea {
            width: 100%; padding: 10px 12px; border: 1px solid var(--border); border-radius: 8px;
            font-size: 14px; box-sizing: border-box; background: #fff; color: var(--text-main);
            font-family: monospace; resize: vertical;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        textarea { min-height: 120px; }
        
        input:focus, select:focus, textarea:focus { 
            outline: none; border-color: var(--primary); 
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1); 
        }

        /* æŒ‰é’®æ ·å¼ */
        .btn { 
            padding: 10px 20px; border: none; border-radius: 8px; 
            font-weight: 600; cursor: pointer; transition: all 0.2s; font-size: 0.95rem;
            height: 42px; /* å¯¹é½é«˜åº¦ */
            display: inline-flex; align-items: center; justify-content: center;
        }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-hover); }
        .btn-block { width: 100%; font-size: 1.1rem; padding: 12px; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; background: #9ca3af; }

        /* çŠ¶æ€æç¤º */
        .status-bar { 
            margin-top: 15px; font-size: 0.9em; min-height: 1.5em; font-weight: 500;
        }
        .text-success { color: #22c55e; }
        .text-error { color: #ef4444; }
        .text-warn { color: #f59e0b; }

        .result-box {
            background: #f1f5f9; border: 1px solid var(--border);
            cursor: pointer;
        }

        /* é”™è¯¯æ¨ªå¹… */
        .error-banner {
            background: #fee2e2; color: #991b1b; padding: 15px; border-radius: 8px; 
            margin-bottom: 20px; border: 1px solid #f87171; display: none;
            text-align: center; font-weight: 600;
        }
        
        /* åˆ†éš”çº¿ */
        .divider { 
            height: 1px; background: var(--border); margin: 25px 0; 
        }
    </style>
</head>
<body>

<div class="container">
    <h1>RSA åŠ å¯†/è§£å¯†å·¥å…·</h1>
    
    <div id="envWarning" class="error-banner">
        âŒ é”™è¯¯ï¼šWeb Crypto API éœ€è¦ HTTPS æˆ– localhost ç¯å¢ƒã€‚
    </div>
    
    <div class="card">
        <div class="flex-row">
            <div class="input-wrapper" style="flex: 0 0 auto; width: 150px;">
                <label for="keySize">å¯†é’¥ä½æ•°</label>
                <select id="keySize">
                    <option value="2048" selected>2048 bits</option>
                    <option value="3072">3072 bits</option>
                    <option value="4096">4096 bits</option>
                </select>
            </div>
            <div class="input-wrapper" style="flex: 0 0 auto; width: 150px;">
                <label for="keyFormat">æ ¼å¼</label>
                <select id="keyFormat" disabled title="ç›®å‰ä»…æ”¯æŒæ ‡å‡† PEM æ ¼å¼">
                    <option value="pem" selected>PEM (Base64)</option>
                </select>
            </div>
            <div class="input-wrapper">
                <button id="generateKeyBtn" class="btn btn-primary" style="width: 100%;">âš¡ ç”Ÿæˆæ–°å¯†é’¥å¯¹</button>
            </div>
        </div>
        <div id="keyStatus" class="status-bar text-success" style="margin-bottom: 15px; margin-top: -10px;"></div>

        <div class="grid-2">
            <div class="input-wrapper">
                <label for="pemPublicKey">å…¬é’¥ (Public Key) - ç”¨äºåŠ å¯†</label>
                <textarea id="pemPublicKey" placeholder="åœ¨æ­¤ç”Ÿæˆæˆ–ç²˜è´´å…¬é’¥ (SPKI PEMæ ¼å¼)..."></textarea>
            </div>
            <div class="input-wrapper">
                <label for="pemPrivateKey">ç§é’¥ (Private Key) - ç”¨äºè§£å¯†</label>
                <textarea id="pemPrivateKey" placeholder="åœ¨æ­¤ç”Ÿæˆæˆ–ç²˜è´´ç§é’¥ (PKCS#8 PEMæ ¼å¼)..."></textarea>
            </div>
        </div>

        <div class="divider"></div>

        <div class="input-wrapper">
            <label for="contentInput">æ•°æ®å†…å®¹ (è‡ªåŠ¨è¯†åˆ«åŠ å¯†/è§£å¯†)</label>
            <textarea id="contentInput" placeholder="è¾“å…¥æ˜æ–‡ï¼Œè‡ªåŠ¨åˆ‡æ¢ä¸ºã€åŠ å¯†ã€‘ï¼›
è¾“å…¥ Base64 å¯†æ–‡ï¼Œè‡ªåŠ¨åˆ‡æ¢ä¸ºã€è§£å¯†ã€‘...
(æ”¯æŒæŒ‰ Enter é”®å¿«é€Ÿæ‰§è¡Œ)"></textarea>
        </div>

        <button id="mainActionBtn" class="btn btn-primary btn-block">ğŸ”’ åŠ å¯†</button>
        
        <div id="actionStatus" class="status-bar"></div>

        <div class="input-wrapper" style="margin-top: 15px;">
            <label for="resultOutput">å¤„ç†ç»“æœ</label>
            <textarea id="resultOutput" class="result-box" readonly title="åŒå‡»è‡ªåŠ¨å¤åˆ¶ç»“æœ" placeholder="ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
        </div>
    </div>
</div>

<script>
    // --- é…ç½®å¸¸é‡ ---
    const RSA_ALGORITHM = 'RSA-OAEP';
    const HASH_ALGORITHM = 'SHA-256';

    // --- DOM å…ƒç´  ---
    const keySize = document.getElementById('keySize');
    const generateKeyBtn = document.getElementById('generateKeyBtn');
    const keyStatus = document.getElementById('keyStatus');
    
    const pemPublicKey = document.getElementById('pemPublicKey');
    const pemPrivateKey = document.getElementById('pemPrivateKey');
    
    const contentInput = document.getElementById('contentInput');
    const mainActionBtn = document.getElementById('mainActionBtn');
    const actionStatus = document.getElementById('actionStatus');
    const resultOutput = document.getElementById('resultOutput');
    const envWarning = document.getElementById('envWarning');

    // --- åˆå§‹åŒ– ---
    window.onload = function() {
        if (!window.isSecureContext || !window.crypto || !window.crypto.subtle) {
            envWarning.style.display = 'block';
            generateKeyBtn.disabled = true;
            mainActionBtn.disabled = true;
            return;
        }

        // äº‹ä»¶ç»‘å®š
        generateKeyBtn.addEventListener('click', generateKeyPair);
        mainActionBtn.addEventListener('click', handleMainAction);
        contentInput.addEventListener('input', updateUIState);
        
        // å›è½¦æ‰§è¡Œ
        contentInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleMainAction();
            }
        });

        // åŒå‡»å¤åˆ¶
        resultOutput.addEventListener('dblclick', copyResult);

        updateUIState(); // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
    };

    // --- æ ¸å¿ƒé€»è¾‘ï¼šç”Ÿæˆå¯†é’¥ ---
    async function generateKeyPair() {
        const bits = parseInt(keySize.value);
        keyStatus.textContent = 'æ­£åœ¨ç”Ÿæˆå¯†é’¥å¯¹ï¼Œè¯·ç¨å€™...';
        keyStatus.className = 'status-bar text-warn';
        generateKeyBtn.disabled = true;

        try {
            const keyPair = await window.crypto.subtle.generateKey(
                {
                    name: RSA_ALGORITHM,
                    modulusLength: bits,
                    publicExponent: new Uint8Array([1, 0, 1]),
                    hash: HASH_ALGORITHM,
                },
                true,
                ['encrypt', 'decrypt']
            );

            // å¯¼å‡ºå…¬é’¥ (SPKI)
            const pubBuffer = await window.crypto.subtle.exportKey('spki', keyPair.publicKey);
            pemPublicKey.value = toPem(pubBuffer, 'PUBLIC KEY');

            // å¯¼å‡ºç§é’¥ (PKCS#8)
            const privBuffer = await window.crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
            pemPrivateKey.value = toPem(privBuffer, 'PRIVATE KEY');

            keyStatus.textContent = `âœ… å¯†é’¥ç”ŸæˆæˆåŠŸ (${bits}-bit)`;
            keyStatus.className = 'status-bar text-success';
        } catch (e) {
            keyStatus.textContent = `âŒ ç”Ÿæˆå¤±è´¥: ${e.message}`;
            keyStatus.className = 'status-bar text-error';
        } finally {
            generateKeyBtn.disabled = false;
        }
    }

    // --- æ ¸å¿ƒé€»è¾‘ï¼šæ™ºèƒ½åˆ¤æ–­ä¸æ‰§è¡Œ ---
    function updateUIState() {
        const text = contentInput.value.trim();
        // ç®€å•åˆ¤æ–­ï¼šå¦‚æœæ˜¯ Base64 ä¸”é•¿åº¦åˆç†ï¼Œè®¤ä¸ºæ˜¯å¯†æ–‡
        const isCipher = text.length > 20 && /^[A-Za-z0-9+/=\s]+$/.test(text);

        if (isCipher) {
            mainActionBtn.textContent = 'ğŸ”“ è§£å¯†';
            mainActionBtn.dataset.action = 'decrypt';
        } else {
            mainActionBtn.textContent = 'ğŸ”’ åŠ å¯†';
            mainActionBtn.dataset.action = 'encrypt';
        }
    }

    function handleMainAction() {
        const action = mainActionBtn.dataset.action;
        if (action === 'decrypt') {
            doDecrypt();
        } else {
            doEncrypt();
        }
    }

    // --- åŠ å¯†é€»è¾‘ ---
    async function doEncrypt() {
        const keyPem = pemPublicKey.value.trim();
        const content = contentInput.value;
        
        if (!keyPem) return setStatus('âŒ è¯·å…ˆç”Ÿæˆæˆ–ç²˜è´´å…¬é’¥', 'error');
        if (!content) return setStatus('âŒ è¯·è¾“å…¥è¦åŠ å¯†çš„å†…å®¹', 'error');

        // æ£€æŸ¥é•¿åº¦
        const bits = parseInt(keySize.value) || 2048; // ä¼°ç®—
        const maxBytes = (bits / 8) - 66; // OAEP SHA-256 overhead approx
        const contentBytes = new TextEncoder().encode(content);
        if (contentBytes.length > maxBytes) {
            return setStatus(`âŒ å†…å®¹è¿‡é•¿ (${contentBytes.length} bytes)ã€‚å½“å‰å¯†é’¥æœ€å¤§æ”¯æŒçº¦ ${maxBytes} bytesã€‚`, 'error');
        }

        try {
            const key = await importKey(keyPem, 'encrypt');
            const encrypted = await window.crypto.subtle.encrypt(
                { name: RSA_ALGORITHM }, key, contentBytes
            );
            resultOutput.value = arrayBufferToBase64(encrypted);
            setStatus('âœ… åŠ å¯†æˆåŠŸ', 'success');
        } catch (e) {
            setStatus(`âŒ åŠ å¯†å¤±è´¥: ${e.message}`, 'error');
        }
    }

    // --- è§£å¯†é€»è¾‘ ---
    async function doDecrypt() {
        const keyPem = pemPrivateKey.value.trim();
        const content = contentInput.value.trim();

        if (!keyPem) return setStatus('âŒ è¯·å…ˆç”Ÿæˆæˆ–ç²˜è´´ç§é’¥', 'error');
        if (!content) return setStatus('âŒ è¯·è¾“å…¥å¯†æ–‡', 'error');

        try {
            const key = await importKey(keyPem, 'decrypt');
            const dataBuffer = base64ToArrayBuffer(content);
            const decrypted = await window.crypto.subtle.decrypt(
                { name: RSA_ALGORITHM }, key, dataBuffer
            );
            resultOutput.value = new TextDecoder().decode(decrypted);
            setStatus('âœ… è§£å¯†æˆåŠŸ', 'success');
        } catch (e) {
            setStatus(`âŒ è§£å¯†å¤±è´¥: å¯†é’¥ä¸åŒ¹é…æˆ–æ•°æ®æŸå`, 'error');
        }
    }

    // --- è¾…åŠ©å‡½æ•° ---
    
    async function importKey(pem, usage) {
        // æ¸…ç† PEM å¤´å°¾å’Œæ¢è¡Œ
        const b64 = pem.replace(/-----[^-]+-----/g, '').replace(/\s/g, '');
        const binary = base64ToArrayBuffer(b64);
        
        return window.crypto.subtle.importKey(
            usage === 'encrypt' ? 'spki' : 'pkcs8',
            binary,
            { name: RSA_ALGORITHM, hash: HASH_ALGORITHM },
            false,
            [usage]
        );
    }

    function toPem(buffer, label) {
        const b64 = arrayBufferToBase64(buffer);
        // æ¯64å­—ç¬¦æ¢è¡Œ
        const lines = b64.match(/.{1,64}/g).join('\n');
        return `-----BEGIN ${label}-----\n${lines}\n-----END ${label}-----`;
    }

    function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
        return btoa(binary);
    }

    function base64ToArrayBuffer(base64) {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        return bytes.buffer;
    }

    function setStatus(msg, type) {
        actionStatus.textContent = msg;
        actionStatus.className = `status-bar text-${type}`;
    }

    function copyResult() {
        if(!resultOutput.value) return;
        resultOutput.select();
        document.execCommand('copy');
        const oldText = actionStatus.textContent;
        setStatus('ğŸ“‹ å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼', 'success');
        setTimeout(() => actionStatus.textContent = oldText, 2000);
    }
</script>
</body>
</html>
